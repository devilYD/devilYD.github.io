---
layout:         post
title:          AOP
subtitle:       面向切面编程
date:           2022-10-29
auther:         YD
header-img:     img/YD-Spring.jpg
catalog:            true
tags:
        - JAVA
        - Spring
        - 笔记

---

# AOP面向切面编程

## 简介

* AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，知道开发者如何组织程序结构
  * OOP(Object Oriented Programming)面向对象编程
* 作用：在不惊动原始设计的基础上为其进行功能增强
* Spring理念：无入侵式/无侵入式编程
* AOP中原方法被称为*连接点*，需要追加功能的方法被称为*切入点*，共性功能被称为*通知*，用来描述通知和切入点之间的关系被称为*切面*，用来存放这些通知的类被称为通知类。

## 核心概念

* 以下为详细定义：
  * 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等
    * 在SpringAOP中，理解为方法的执行
  * 切入点(Pointcut)：匹配连接点的式子
    * 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
      * 一个具体方法：某个接口中的无形参无返回值的save方法
      * 匹配多个方法：所有的get开头的方法，所有的save方法，所有以mapper结尾的接口中的所有方法，所有带有一个参数的方法
  * 通知(Advice)：在切入点执行的操作，也就是共性功能
    * 在SpringAOD中，功能最终以方法的形式呈现
  * 通知类：定义通知的类
  * 切面(Aspect)：描述通知与切入点的对应关系
  * 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的
  * 代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现

连接点包含切入点。

## AOP入门案例

案例：在接口执行前输出当前系统的事件

开发模式：注解

思路分析：
1. 导入依赖
2. 制作共性功能(通知类与通知)
3. 定义切入点
4. 绑定切入点与通知关系(切面)

那么首先导入依赖，由于Spring-AOP包含于spring-context包中，故如下：

```XML
        <!--Spring核心框架-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.18</version>
        </dependency>
        <!--AOP相关-->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.9</version>
        </dependency>
```

其次需要设定Spring自动加载关于AOP的注解，在Spring的设置类中添加注解`@EnableAspectJAutoProxy`

然后定义通知类与通知，在类前添加注解`@Component`和`@Aspect`即可声明此类为通知类并加载

定义通知如下：
```JAVA
    @Pointcut("execution(void org.YD.pojo.User.setId())")
    private void cut0(){}//切入点

    @Before("cut0()")//切面
    public void method() {//通知
        System.out.println(System.currentTimeMillis());
    }
```

这样就完成了通知的定义和切入点，切面的描述。

## AOP工作流程

1. Spring容器启动
2. 读取所有切面配置中的切入点(只读取使用了的切入点)
3. 初始化bean，判定bean对应的类中方法是否匹配到任意切入点
   * 匹配失败，创建对象
   * 匹配成功，创建原始对象(目标对象)的代理对象
4. 获取bean执行方法
   * 获取bean调用方法并执行，完成操作
   * 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作

注意，Spring在代理对象时会自动重写对象的toString方法，判断一个对象是否是代理对象的正确方法是打印它的类型。

SpringAOP的本质：代理模式

## AOP切入点表达式

* 切入点：要进行增强的方法
* 切入点表达式：要进行增强的方法的描述方式
* 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类名/接口名.方法名(参数)异常名)

```JAVA
execution(void org.YD.pojo.User.setId())
```
* 动作关键字：描述切入点的行为动作，例如`execution`表示执行到指定切入点
* 访问修饰符：public、private等，可以省略
* 返回值
* 包名
* 类/接口名
* 方法名
* 参数
* 异常名：方法中抛出指定异常，可以省略

* 可以使用通配符描述切入点，快速描述：
  * `*`：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现(必有一个出现)
  * `..`：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写方法(可有可无)
  * `+`：专用于匹配子类类型

匹配项目下所有方法：`* *..*(..)`任意返回类型任意包下的任意方法以及任意参数

* 书写技巧：
  * 所有代码按照标准规范开发，否则以下技巧全部失效
  * 描述切入点通常描述接口，而不描述实现类
  * 访问控制修饰符针对接口开发均采用`public`描述(可省略访问控制符描述)
  * 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用`*`通配符快速匹配
  * 包名书写尽量不使用`..`匹配，效率过低，常采用*做单个包描述匹配，或精准匹配
  * 接口名类名书写名称与模块相关的采用`*`匹配，例如`UserService`书写成`*Service`，绑定业务层接口名
  * 方法名书写以动词进行精准匹配，名词采用`*`匹配，例如`getById`书写成`get*`
  * 参数规则较为复杂，根据业务方法灵活调整
  * 通常不使用异常作为匹配规则

总而言之，最基础的还是代码规范。

## AOP通知类型

* AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置
* AOP通知共分为5中类型
  * 前置通知：`@Before("切入点方法")`
  * 后置通知：`@After("切入点方法")`
  * 环绕通知：`@Around("切入点方法")`，在通知的参数列表中传入一个`ProceedingJoinPoint`类型对象并在通知的函数体中用此对象的`proceed()`方法表示对原始操作的调用，另外环绕通知的返回值要和切入点方法相同，一般使用`Object`类型，原始方法的返回值会由`proceed()`方法返回，最后将这个值返回即可。
  * 返回后通知：`@AfterReturning`
  * 抛出异常后通知：`@AfterThrowing`
* `@Around`注意事项
  * 环绕通知中必须依赖形参`ProceedingJoinPoint`才能实现对原始方法的调用，进而实现原始方法调用前后同时添加功能
  * 通知中如果未使用`ProceedingJoinPoint`对原始方法进行调用将跳过原始方法的执行
  * 对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，必须设定为`Object`类型
  * 原始方法的返回值如果是void类型，通知方法的返回类型可以设置成void，也可以设置成`Object`
  * 由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出`Throwable`对象

其中环绕通知可以用来实现权限校验。

## AOP通知获取数据

* 获取切入点方法的参数
  * `JoinPoint`：适用于前置、后置、返回后、抛出异常后通知
  * `ProceedJoinPoint`：适用于环绕通知
* 获取切入点方法返回值
  * 返回后通知
  * 环绕通知
* 获取切入点方法运行异常信息
  * 抛出异常后通知
  * 环绕通知
* 获取切入点方法参数的方法：
  * `getArgs()`：获取切入点方法的形参数组，可以修改这个数组的数据再传回`proceed()`方法执行以此修改参数
* 获取切入点返回值：
  * 返回后通知：
    * 在通知参数中键入`Object`类型的形参用于存储返回值
    * 在`@AfterReturning`注释的属性中，将原本的切入点设置为属性名`value`，再设置`returning`属性为`Object`形参的变量名
    * 在通知中直接使用传入的形参即可
    * 注意，若同时需要`JoinPoint`和此形参，则将`JoinPoint`作为第一个形参
  * 环绕通知：
    * 执行`proceed()`方法本身就会返回原方法的返回值
* 获取异常：
  * 抛出异常后通知：
    * 在通知参数中加入`Throwable`类型的形参
    * 在`AfterThrowing`注释的属性中，将原本的切入点设置为属性名`value`，再设置`throwing`属性为形参名
    * 在通知中直接使用即可
  * 环绕通知：
    * 直接`try...throw`即可