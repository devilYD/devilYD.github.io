---
layout:         post
title:          Java基础(一)
subtitle:       八股文
date:           2022-11-20
auther:         YD
header-img:     img/java.jpg
catalog:            true
tags:
        - JAVA
        - 笔记

---

# Java基础

## JVM、JRE、JDK之间的关系

* JVM：Java虚拟机
* JRE：Java运行环境，不能创建新程序，包含JVM
* JDK：包括编译器以及各种开发者工具

## public、protected、default和private的区别

* `default`是默认的，什么都不写，在同一个包内是可见的，不使用任何修饰符
* `public`是指公有的，能够用来修饰类，在一个Java源文件中只有一个类被声明为`public`，而且一旦有一个类为`public`，那这个Java源文件的文件名就必须要和这个被`public`修饰的类的类名相同，否则编译不能通过；`public`用来修饰类中成员(变量和方法)，被`public`所修饰的成员可以在任何类中被访问。
* `protected`指受保护的，受到该类所在的包所保护，被`protected`所修饰的成员会被位于同一package中的所有类访问到；同时，被`protected`修饰的成员也能被该类的所有子类继承下来。
* `private`是私有的，即只能在当前类中被访问到，作用域最小。

|作用域|当前类|同一package|子孙类|其他package|
|-----|------|-----------|-----|-----------|
|public|✔|✔|✔|✔|
|protect|✔|✔|✔|×|
|default|✔|✔|×|×|
|private|✔|×|×|×|

## final、finally、finalize的区别

* `final`意为不可变，可以修饰变量、方法和类。修饰变量时，这个变量必须初始化，所以也被称为常量。
* `finally`是异常处理的一部分，只能用于`try/catch`中，并且附带一个语句块表示这段话一定会被执行，无论是否抛出异常。
* `finalize`是java.lang.Object中的方法，也就是每一个对象都有这个方法，一个对象的finalize方法只会调用一次，调用了不一定被回收，因为只有对象被回收时才会被回收，就会导致前面调用，后面回收的时候出现问题，不推荐使用。

```JAVA
try {
    // 可能出现异常的语句
} catch (Exception e) {
    // try中出现异常执行的语句
} finally {
    // 无论出不出异常都会执行的语句
}
```

## static关键字的作用

通常情况下需要new对象之后才能，数据的存储空间才会被分配，方法才能供外界调用。但是当没有创建对象的时候也想要调用方法或者就是香味特定成员分配空间的时候，就需要用到`static`。所以有了`static`，成员变量或者方法就可以在没有所属类的时候被访问了。

* `static`修饰属性时
  * 该属性能被所有该类的实例对象访问，且所有实例对象访问的都是同一个存储空间
* `static`修饰方法时
  * 该方法属于类，而不属于类的对象
  * 可以直接调用该方法而无需创建类的实例
  * 该方法可以访问静态数据成员，并可以更改静态数据成员的值
* 静态代码块
  * 用于初始化静态数据成员
  * 它在类加载时在main方法之前执行

```JAVA
    static {
        String resource = "mybatis-config.xml";
        try {
            InputStream inputStream = Resources.getResourceAsStream(resource);
            factory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
```

如上就是一个静态代码块，用于MyBatis的初始化。

## 面向对象、面向过程

* 面向过程的性能比较高，因为没有实例化等操作，开销比较小。
* 面对对象由于有了封装、继承、多态的特性，可以设计处低耦合的系统，使得系统更加灵活、容易维护。
  * 封装是指封装成抽象的类，并且对于可信的类或者对象，是可以操作的，对于不可信的进行隐藏。
  * 继承是指可以使用现有类的所有功能，并且还可以在现有功能的基础上做拓展。
  * 多态是基于继承的，他是指父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或者表现出不同的行为，使得同一个属性在父类以及其子类中具有不同的含义
    * 重载就是多态的一个例子，是编译时多态；上面的多态指的是运行时多态，也就是编译的时候不确定调用哪个具体的方法，一直延迟到运行时才可以确定，所以多态又叫延迟方法。
      * 重载和重写都是实现多态的方式，区别在于，重载是编译时多态，重写是运行时多态。

## ArrayList

* ArrayList底层就是一个`Object[]`数组
* ArrayList底层数组默认初始化容量为10
  1. jdk1.8中ArrayList底层先创建一个长度为0的数组
  2. 当第一次添加元素(调用`add()`方法)时，会初始化为一个长度为10的数组
* 当ArrayList中的容量使用完之后，则需要对容量进行扩容：
  1. ArrayList容量使用完后，会“自动”创建容量更大的数组，并且将原数组中所有元素拷贝过去，这会导致效率降低
  2. 优化：可以使用构造方法`ArrayList(int capacity)`或者`ensureCapacity(int capacity)`提供一个初始化容量，避免刚开始就一直扩容，造成效率较低
* ArrayList 构造方法：
  1. `ArrayList()`：创建一个初始化容量为10的空列表
  2. `ArrayList(int initalCapacity)`：创建一个指定初始化容量为initalCapacity的空列表
  3. `ArrayList(Collection<?extends E> c)`：创建一个包含指定集合中所有元素的列表
* ArrayList特点：
  * 优点：
    1. 向ArrayList末尾添加元素(`add()`方法)时，效率较高
    2. 查询效率较高
  * 缺点
    1. 扩容会造成效率较低(可以通过指定初始化容量，在一定程度上对其进行改善)
    2. 另外数组无法存储大数据量(因为很难找到一块很大的连续的内存空间)
    3. 向ArrayList中间添加元素`add(int index)`时，需要移动元素，效率较低
       1. 但是，向ArrayList中间位置增/删元素的情况较少时不影响；
       2. 如果增/删操作较多，可以考虑改用链表

## LinkList

### LinkedList特点

* 数据结构：LinkedList底层是一个双向链表
* 优点：增/删效率高
* 缺点：查询效率低
* LinkedList也有下标，但是内存不一定是连续的(类似C++重载[]符号，将循位置模拟为循秩访问)
* LinkedList可以调用`get(int index)`方法，返回链表中第index个元素
  * 但是每次查找都要从头节点开始遍历

### ListIterator接口

1. LinkedList.add方法只能将数据添加到链表的末尾
2. 如果要将对象添加到链表的中间位置，则需要使用ListIterator接口的add方法
   1. ListIterator接口是Iterator的一个子接口
3. Iterator中的remove方法
   1. 调用next之后，remove删除的是迭代器左侧的元素，类似键盘的backspace
   2. 调用previous之后，remove删除的是迭代器右侧的元素
4. ListIterator中add方法
   1. 调用next之后，在迭代器左侧添加一个元素
   2. 调用previous之后，add是在迭代器右侧添加元素

|返回类型|方法|对应的操作|
|-------|----|---------|
|void|add(E e)|将指定的元素插入列表（可选操作）|  
|boolean|hasNext()|返回true如果遍历正向列表，列表迭代器有多个元素|
|boolean|hasPrevious()|返回true如果遍历反向列表，列表迭代器有多个元素|
|E|next()|返回列表中的下一个元素，并且前进光标位置| 
|int|nextIndex()|返回随后调用 next()返回的元素的索引| 
|E|previous()|返回列表中的上一个元素，并向后移动光标位置|
|int|previousIndex()|返回由后续调用 previous()返回的元素的索引|
|void|remove()|从列表中删除由 next()或 previous()返回的最后一个元素（可选操作）| 
|void|set(E e)|用指定的元素替换由 next()或 previous()返回的最后一个元素（可选操作）| 

## Vector

* Vector底层是数组
* 初始化容量为10
* 扩容：原容量使用完后，会进行扩容。新容量扩大为原始容量的2倍
* Vector是线程安全的(里面的方法都带有synchronized关键字)，效率较低，限制使用较少
* 如何将ArrayList变成线程安全的？
  * 调用Collections工具类中的`static List synchronizedList(List list)`方法

## Set

* 泛型
  1. jdk 1.5 引入，之前都是使用Object[]
  2. 使用Object[]的缺点
     1. 获取一个值时必须进行强制类型转换
     2. 调用一个方法前必须使用instanceof判断对象类型
* 泛型的好处：
  1. 减少了强制类型转换的次数，获取数据值更方便
  2. 类型安全，调用方法时更安全
  3. 泛型只在编译时期起作用，运行阶段JVM看不见泛型类型(JVM只能看见对应的原始类型，因为进行了类型擦除)
  4. 带泛型的类型，在使用时没有指定泛型类型时，默认使用Object类型
  5. lambda表达式

## HashSet

* 特点：HashSet无序(没有下标)，不可重复

## TreeSet

* TreeSet无序(没有下标)，不可重复，但是可以排序
* HashSet为HashMap的key部分；TreeSet为TreeMap的key部分
* 故重点掌握HashMap和TreeMap

## Map

1. Map和Collection没有继承关系
2. Map以`(key,value)`的形式存储数据：键值对
   * key和value存储的都是对象的内存地址(引用)

### Map接口常见方法

|方法|功能|
|---|----|
|`set<K> keySet()`|返回Map中的key集合|
|`Collection<V> values()`|返回Map中value的集合|
|`Set<Map.Entry<K,V>> entrySet()`|返回Map中对应的Map.Entry集合(set)|
|`V put(K Key,V Value)`|向Map中添加键为Key，值为Value的键值对，若Map中已有Key，则更新其对应的Value值|
|`V get(Object key)`|返回Map中Key对应的Value，若Map中不包含Key，则返回`null`|
|`default V getOrDefault(Object key, V defaultValue)`|返回Map中Key对应的value；若Map中不含Key，则返回`defaultValue`|
|`V remove(Object key)`|移除Map中Key|
|`void clear()`|清空Map|
|`boolean isEmpty()`|判空(判断Map中size是否为0)|
|`boolean containsKey(Object key)`|查看Map中是否包含key|
|`boolean containsValue(Object Value)`|查看Map中是否包含value|

注意：`Map.Entry<K,V>`是Map的一个接口。接口中的内部接口默认是public static的。

### Map的遍历方式

* 第一类方法
  * 先获取Map的keySet，然后取出key对应的value
    * 特点：
      * 效率相对较低(因为还要根据key从哈希表中查找对应的value)
* 第二类方法
  * 调用Map.entryset()方法，获取entrySet，然后直接虫entrySet中获取key和value。
    * 特点：
      1. 效率较高(直接从Map中获取key，value)
      2. 适用于大数据量Map遍历

## HashMap

1. HashMap底层是一个数组
2. 数组中每个元素是一个单向链表(即采用拉链法解决哈希冲突)
   * 单链表的节点：每个节点是`Node<K,V>`类型
3. 同一个单链表中所有Node的hash值不一定一样，但是他们对应的数组下标一定一样
   * 数组下标利用哈希函数/哈希算法根据hash值计算得到的
4. HashMap是数组和单链表的结合体
   1. 数组查询效率高，但是增删元素效率较低
   2. 单链表在随机增删元素方面效率较高，但是查询效率较低
   3. HashMap将二者结合起来，充分发挥它们各自的优点
5. HashMap的特点
   1. 无序、不可重复
   2. 无序：因为不一定挂在哪个单链表上了
6. 如何保证不可重复：
   * 通过重写equals方法保证的

### 关于HashMap的初始化

1. HashMap默认初始化容量： 16
   1. 必须是2的次幂，这也是jdk官方推荐的
   2. 这是因为达到散列均匀，为了提高HashMap集合的存取率所必须的
2. HashMap默认加载因子：0.75
   * 数组容量达到3/4时开始扩容
3. JDK 8 之后，对HashMap底层数据结构(单链表)进行了改进
   1. 如果单链表元素超过8个，则将单链表转变为红黑树
   2. 如果红黑树节点数量小于6时，会将红黑树重新变为单链表

这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围、提高效率。


