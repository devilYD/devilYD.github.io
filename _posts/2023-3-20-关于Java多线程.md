---
layout:         post
title:          关于Java多线程
subtitle:       语言特性
date:           2023-2-23
auther:         YD
header-img:     img/YD-littleroad.jpg
catalog:            true
tags:
        - JAVA
        - 笔记

---

# 关于Java多线程

## 线程与进程

* 进程和线程基本概念
  * 进程：进程是操作系统资源分配的基本实体
  * 线程：线程是CPU调度和分配的基本单位
* 进程和线程的关系
  * 一个线程只能属于一个进程，但是一个进程可以有多个线程（至少一个线程），一个线程的进程叫做单线程进程，多个线程的进程叫做多线程进程
  * 资源分配给进程之后，进程内部的线程都可以共享该进程的资源
  * 在处理机上运行的是线程
  * 线程在执行的过程中需要协作同步，不同进程的线程需要利用消息通信来实现同步
* 进程和线程的区别
  * 基本区别：进程是操作系统分配资源的基本实体，线程是CPU调度的基本单位
  * 开销方面：每个进程都有自己独立的代码和数据空间，因此进程之间的切换会有较大的开销。但是线程在进程的地址空间内部运行，因此同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，因此线程之间的切换开销小。
  * 所处环境：在操作系统中能同时运行多个进程，在同一个进程中有多个线程同时执行
  * 内存分配：系统在运行的时候会给每个进程分配不同的内存空间，但是不会给线程分配，线程使用的资源均来自于进程
  * 包含关系：线程是进程的一部分，没有线程的进程叫做单线程进程，有多个线程的进程叫做多线程进程


## Java与多线程的基本关系

* Java程序天生就是多线程程序，我们可以通过JMX来看一下一个普通的Java程序有哪些线程，代码如下：

```JAVA
public class MultiThread {
	public static void main(String[] args) {
		// 获取 Java 线程管理 MXBean
		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息
		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
		// 遍历线程信息，仅打印线程 ID 和线程名称信息
		for (ThreadInfo threadInfo : threadInfos) {
			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());
		}
	}
}
```

* 上述程序的输出如下：

```
[6] Monitor Ctrl-Break //监听线程转储或“线程堆栈跟踪”的线程
[5] Attach Listener //负责接收到外部的命令，而对该命令进行执行的并且把结果返回给发送者
[4] Signal Dispatcher // 分发处理给 JVM 信号的线程
[3] Finalizer //在垃圾收集前，调用对象 finalize 方法的线程
[2] Reference Handler //用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收的线程
[1] main //main 线程,程序入口
```

* 能够得出结论：一个 Java 程序的运行是 main 线程和多个其他线程同时运行

## 如何实现多线程编程

* 若想在Java中实现多线程的定义，那么就需要实现一个专门的线程主体类进行线程执行任务的定义，这个主题类是需要实现特定的接口或继承特定的父类进行实现

### 通过继承Thread类实现多线程

* Java提供有一个java.lang.Thread类作为线程主体类的父类，一个类只要继承了此类就表示这个类是一个线程主体类了，但不是说这个类就可以直接实现多线程处理了，因为还需要覆写Thread类中的run方法作为多线程的主方法。

```JAVA
/**
 * 一个类继承Thread类即为线程主体类
 * 需要覆写run方法作为线程的主方法
 */
public class ThreadDemo extends Thread{

    private String title;

    public ThreadDemo(String title) {
        this.title = title;
    }

    @Override
    public void run() {
        for (int i = 0;i<10;i++){
            System.out.println(title + "执行：i=" + i);
        }
    }
}
```

编写测试：

```JAVA
/**
 * 多线程编程测试
 */
public class ThreadDemoTest {
    @Test
    public void threadTest() {
        ThreadDemo threadDemo0 = new ThreadDemo("A");
        ThreadDemo threadDemo1 = new ThreadDemo("B");
        ThreadDemo threadDemo2 = new ThreadDemo("C");
        ThreadDemo threadDemo3 = new ThreadDemo("D");

        threadDemo0.start();
        threadDemo1.start();
        threadDemo2.start();
        threadDemo3.start();
    }
}
```

* 运行后可发现输出明显为异步运行，即多线程
* 可以发现调用的是start方法而不是run，这是由于本质上run方法只是一个普通方法，需要使用start方法调用系统的线程管理算法分配资源来异步的运行run方法
* 任何情况下，只要手动定义了多线程覆写run方法，就需要使用start方法来启动。








