---
layout:         post
title:          Java基础
subtitle:       八股文
date:           2022-11-20
auther:         YD
header-img:     img/java.jpg
catalog:            true
tags:
        - JAVA
        - 笔记

---

# Java基础

## JVM、JRE、JDK之间的关系

* JVM：Java虚拟机
* JRE：Java运行环境，不能创建新程序，包含JVM
* JDK：包括编译器以及各种开发者工具

## public、protected、default和private的区别

* `default`是默认的，什么都不写，在同一个包内是可见的，不使用任何修饰符
* `public`是指公有的，能够用来修饰类，在一个Java源文件中只有一个类被声明为`public`，而且一旦有一个类为`public`，那这个Java源文件的文件名就必须要和这个被`public`修饰的类的类名相同，否则编译不能通过；`public`用来修饰类中成员(变量和方法)，被`public`所修饰的成员可以在任何类中被访问。
* `protected`指受保护的，受到该类所在的包所保护，被`protected`所修饰的成员会被位于同一package中的所有类访问到；同时，被`protected`修饰的成员也能被该类的所有子类继承下来。
* `private`是私有的，即只能在当前类中被访问到，作用域最小。

|作用域|当前类|同一package|子孙类|其他package|
|-----|------|-----------|-----|-----------|
|public|✔|✔|✔|✔|
|protect|✔|✔|✔|×|
|default|✔|✔|×|×|
|private|✔|×|×|×|

## final、finally、finalize的区别

* `final`意为不可变，可以修饰变量、方法和类。修饰变量时，这个变量必须初始化，所以也被称为常量。
* `finally`是异常处理的一部分，只能用于`try/catch`中，并且附带一个语句块表示这段话一定会被执行，无论是否抛出异常。
* `finalize`是java.lang.Object中的方法，也就是每一个对象都有这个方法，一个对象的finalize方法只会调用一次，调用了不一定被回收，因为只有对象被回收时才会被回收，就会导致前面调用，后面回收的时候出现问题，不推荐使用。

```JAVA
try {
    // 可能出现异常的语句
} catch (Exception e) {
    // try中出现异常执行的语句
} finally {
    // 无论出不出异常都会执行的语句
}
```

## static关键字的作用

通常情况下需要new对象之后才能，数据的存储空间才会被分配，方法才能供外界调用。但是当没有创建对象的时候也想要调用方法或者就是香味特定成员分配空间的时候，就需要用到`static`。所以有了`static`，成员变量或者方法就可以在没有所属类的时候被访问了。

* `static`修饰属性时
  * 该属性能被所有该类的实例对象访问，且所有实例对象访问的都是同一个存储空间
* `static`修饰方法时
  * 该方法属于类，而不属于类的对象
  * 可以直接调用该方法而无需创建类的实例
  * 该方法可以访问静态数据成员，并可以更改静态数据成员的值
* 静态代码块
  * 用于初始化静态数据成员
  * 它在类加载时在main方法之前执行

```JAVA
    static {
        String resource = "mybatis-config.xml";
        try {
            InputStream inputStream = Resources.getResourceAsStream(resource);
            factory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
```

如上就是一个静态代码块，用于MyBatis的初始化。

## 面向对象、面向过程

* 面向过程的性能比较高，因为没有实例化等操作，开销比较小。
* 面对对象由于有了封装、继承、多态的特性，可以设计处低耦合的系统，使得系统更加灵活、容易维护。
  * 封装是指封装成抽象的类，并且对于可信的类或者对象，是可以操作的，对于不可信的进行隐藏。
  * 继承是指可以使用现有类的所有功能，并且还可以在现有功能的基础上做拓展。
  * 多态是基于继承的，他是指父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或者表现出不同的行为，使得同一个属性在父类以及其子类中具有不同的含义
    * 重载就是多态的一个例子，是编译时多态；上面的多态指的是运行时多态，也就是编译的时候不确定调用哪个具体的方法，一直延迟到运行时才可以确定，所以多态又叫延迟方法。
      * 重载和重写都是实现多态的方式，区别在于，重载是编译时多态，重写是运行时多态。

## ArrayList

* ArrayList底层就是一个`Object[]`数组
* ArrayList底层数组默认初始化容量为10
  1. jdk1.8中ArrayList底层先创建一个长度为0的数组
  2. 当第一次添加元素(调用`add()`方法)时，会初始化为一个长度为10的数组
* 当ArrayList中的容量使用完之后，则需要对容量进行扩容：
  1. ArrayList容量使用完后，会“自动”创建容量更大的数组，并且将原数组中所有元素拷贝过去，这会导致效率降低
  2. 优化：可以使用构造方法`ArrayList(int capacity)`或者`ensureCapacity(int capacity)`提供一个初始化容量，避免刚开始就一直扩容，造成效率较低
* ArrayList 构造方法：
  1. `ArrayList()`：创建一个初始化容量为10的空列表
  2. `ArrayList(int initalCapacity)`：创建一个指定初始化容量为initalCapacity的空列表
  3. `ArrayList(Collection<?extends E> c)`：创建一个包含指定集合中所有元素的列表
* ArrayList特点：
  * 优点：
    1. 向ArrayList末尾添加元素(`add()`方法)时，效率较高
    2. 查询效率较高
  * 缺点
    1. 扩容会造成效率较低(可以通过指定初始化容量，在一定程度上对其进行改善)
    2. 另外数组无法存储大数据量(因为很难找到一块很大的连续的内存空间)
    3. 向ArrayList中间添加元素`add(int index)`时，需要移动元素，效率较低
       1. 但是，向ArrayList中间位置增/删元素的情况较少时不影响；
       2. 如果增/删操作较多，可以考虑改用链表

## LinkList

### LinkedList特点

* 数据结构：LinkedList底层是一个双向链表
* 优点：增/删效率高
* 缺点：查询效率低
* LinkedList也有下标，但是内存不一定是连续的(类似C++重载[]符号，将循位置模拟为循秩访问)
* LinkedList可以调用`get(int index)`方法，返回链表中第index个元素
  * 但是每次查找都要从头节点开始遍历

### ListIterator接口

1. LinkedList.add方法只能将数据添加到链表的末尾
2. 如果要将对象添加到链表的中间位置，则需要使用ListIterator接口的add方法
   1. ListIterator接口是Iterator的一个子接口
3. Iterator中的remove方法
   1. 调用next之后，remove删除的是迭代器左侧的元素，类似键盘的backspace
   2. 调用previous之后，remove删除的是迭代器右侧的元素
4. ListIterator中add方法
   1. 调用next之后，在迭代器左侧添加一个元素
   2. 调用previous之后，add是在迭代器右侧添加元素

|返回类型|方法|对应的操作|
|-------|----|---------|
|void|add(E e)|将指定的元素插入列表（可选操作）|  
|boolean|hasNext()|返回true如果遍历正向列表，列表迭代器有多个元素|
|boolean|hasPrevious()|返回true如果遍历反向列表，列表迭代器有多个元素|
|E|next()|返回列表中的下一个元素，并且前进光标位置| 
|int|nextIndex()|返回随后调用 next()返回的元素的索引| 
|E|previous()|返回列表中的上一个元素，并向后移动光标位置|
|int|previousIndex()|返回由后续调用 previous()返回的元素的索引|
|void|remove()|从列表中删除由 next()或 previous()返回的最后一个元素（可选操作）| 
|void|set(E e)|用指定的元素替换由 next()或 previous()返回的最后一个元素（可选操作）| 

## Vector

* Vector底层是数组
* 初始化容量为10
* 扩容：原容量使用完后，会进行扩容。新容量扩大为原始容量的2倍
* Vector是线程安全的(里面的方法都带有synchronized关键字)，效率较低，限制使用较少
* 如何将ArrayList变成线程安全的？
  * 调用Collections工具类中的`static List synchronizedList(List list)`方法
